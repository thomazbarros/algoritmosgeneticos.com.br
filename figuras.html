<HTML>
<HEAD>
<TITLE>Algoritmos Gen&eacute;ticos</TITLE>
<STYLE TYPE="TEXT/CSS">
BODY,TD {
	font-family: arial,helvetica,sans-serif;
	font-size: 11pt;
}
SMALL {
	font-family: arial,helvetica,sans-serif;
	font-size: 8pt;
	color: gray;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="WHITE" >



<!-- page below here -->

<FONT SIZE=+2>Figuras</FONT><p></CENTER>
Cap&iacute;tulos:
<TABLE BORDER="0" CELLSPACING=1 CELLPADDING=4 WIDTH=750 >
      <TR>
          <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap1">1</A>                  
          </TD>
	  <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap2">2</A>                  
          </TD>
          <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap3">3</A>                  
          </TD>
	  <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap4">4</A>                  
          </TD>
          <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap5">5</A>                  
          </TD>
	  <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap6">6</A>                  
          </TD>
          <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap7">7</A>                  
          </TD>
	  <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap8">8</A>                  
          </TD>
<TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap9">9</A>                  
          </TD>
	  <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap10">10</A>                  
          </TD>
          <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap11">11</A>                  
          </TD>
	  <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap12">12</A>                  
          </TD>
          <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap13">13</A>                  
          </TD>
	  <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap14">14</A>                  
          </TD>
          <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap15">15</A>                  
          </TD>
	  <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#cap16">16</A>                  
          </TD>
	  <TD WIDTH="5%" VALIGN="BOTTOM">
              <B><FONT FACE="Tahoma"><P ALIGN="CENTER">
		  <A HREF="#ApendiceB">Apêndice B</A>                  
          </TD>
        
      </TR>
</TABLE>

<p>

<hr>

<A NAME="cap1"></A>
<FONT SIZE=+1>Cap&iacute;tulo 1</FONT> <p>

<UL>
<LI><A HREF=Figura01.01.jpg>Figura 1.1</A>: C&aacute;lculo do tempo de execu&ccedil;&atilde;o do algoritmo arrayMax.
<LI><A HREF=Figura01.02.jpg>Figura 1.2</A>:Exemplo de um diagrama de classes que mostra que as 
                            classes seres_humanos e cachorros  
                            s&atilde;o descendentes da classe Mam&iacute;feros.
<LI><A HREF=Figura01.03.jpg>Figura 1.3</A>:Exemplo de uma hierarquia de classes com mais 
                            n&iacute;veis. A classe Ve&iacute;culos Terrestres &eacute; sub-classe de Ve&iacute;culos
                            e super-classe de Carros e Motos. Isto faz com que a classe 
                            Ve&iacute;culos seja uma classe ancestral destas duas &uacute;ltimas, que podem
                            herdar atributos e m&eacute;todos tanto de Ve&iacute;culos Terrestres como de Ve&iacute;culos.
<LI><A HREF=Figura01.04.jpg>Figura 1.4</A>:Exemplo de heran&ccedil;a m&uacute;ltipla (n&atilde;o dispon&iacute;vel em Java).
</UL>

<p>
<hr>
<br>

<A NAME="cap2"></A>
<FONT SIZE=+1>Cap&iacute;tulo 2</FONT> <p>

<UL>
<LI><A HREF=Figura02.01.jpg>Figura 2.1</A>: Modelo do funcionamento do splicing. Neste, os 
           introns (regi&atilde;o n&atilde;o codificante de um gene) s&atilde;o removidos, deixando apenas os
           exons. Algo que contribui para a imensa complexidade do ser humano &eacute; que
           existem v&aacute;rias maneiras de fazer splicing. No lado inferior direito vemos o
           mesmo gene sendo “cortado” de outra maneira, em um processo que chamamos de 
           splicing alternativo.  Cada forma diferente de splicing gera uma prote&iacute;na
           diferente, posto que cada seqüência final do gene p&oacute;s-splicing &eacute; diferente
<LI><A HREF=Figura02.02.jpg>Figura 2.2</A>: O dogma central da biologia. O dogma central 
           n&atilde;o &eacute; totalmente verdadeiro. Em alguns experimentos p&ocirc;de-se verificar que a
           quantidade de prote&iacute;na n&atilde;o &eacute; perfeitamente correlacionada com a quantidade de
           RNA que a codifica (na verdade, a correla&ccedil;&atilde;o se aproxima mais de 0,5).
           Isto se deve a outros fatores n&atilde;o embutidos no dogma central, como o controle
           da degrada&ccedil;&atilde;o das mol&eacute;culas de mRNA e entrada de substâncias vindas do ambiente
           extra-celular, entre outros, mas n&oacute;s n&atilde;o discutiremos o conhecimento biol&oacute;gico
           com este n&iacute;vel de profundidade aqui. Para n&oacute;s, o dogma central serve como uma
           excelente aproxima&ccedil;&atilde;o da realidade.
<LI><A HREF=Figura02.03.jpg>Figura 2.3</A>: Processo completo de crossover.
<LI><A HREF=Figura02.04.jpg>Figura 2.4</A>: Dois crossomos realizando o crossover.
<LI><A HREF=Figura02.05.jpg>Figura 2.5</A>: Modelo do grafo formado pelas redes de regula&ccedil;&atilde;o
           celular. Em (a) n&oacute;s vemos um gene sendo regulado por v&aacute;rios outros genes reguladores.
           Entretanto, esta diferen&ccedil;a entre regulados e reguladores n&atilde;o existe. A realidade
           &eacute; como mostrada na figura (b) em que vemos um modelo de rede formado por cinco
           genes que assumem o papel de regulados e reguladores dependendo de qual processo 
           se est&aacute; considerando.
</UL>

<p>
<hr>
<br>

<A NAME="cap3"></A>
<FONT SIZE=+1>Cap&iacute;tulo 3</FONT> <p>

<UL>
<LI><A HREF=Figura03.01.jpg>Figura 3.1</A>: Diagrama que posiciona os algoritmos evolucion&aacute;rios
     como t&eacute;cnica de busca. Eles s&atilde;o t&eacute;cnicas aleat&oacute;rias-guiadas que, assim como as t&eacute;cnicas de
     resfriamento simulado (simulated annealing), têm componentes aleat&oacute;rios, mas dependem do
     estado corrente para determinar seu pr&oacute;ximo estado. Isto &eacute;, a informa&ccedil;&atilde;o conhecida
     direciona a busca, o que diferencia os algoritmos evolucion&aacute;rios de m&eacute;todos puramente
     aleat&oacute;rios como as “random walks”. Em cinza vemos os principais t&oacute;picos deste livro, que
     ser&atilde;o cobertos em detalhes. As outras t&eacute;cnicas de busca s&atilde;o descritas de forma breve no
     apêndice B. 
<LI><A HREF=Figura03.02.jpg>Figura 3.2</A>: Fun&ccedil;&atilde;o hipot&eacute;tica com um m&aacute;ximo local e outro
     global. Uma t&eacute;cnica de gradiente (hill climbing que) se inicie em qualquer um dos
     pontos de in&iacute;cio marcados seguir&aacute; o gradiente (dire&ccedil;&atilde;o de maior crescimento) e
     acabar&aacute; presa no ponto d em&aacute;ximo local (onde a derivada &eacute; zero). Algoritmos gen&eacute;ticos
     n&atilde;o têm esta dependência t&atilde;o forte dos valores iniciais.
<LI><A HREF=Figura03.03.jpg>Figura 3.3</A>: Intui&ccedil;&atilde;o por tr&aacute;s do teorema NFL. Um algoritmo
     elaborado especificamente para o problema A ter&aacute; performance &oacute;tima para este algoritmo
     e seu desempenho se deterior&aacute; rapidamente conforme nos afastamos para problemas bem
     diferentes de A. Um algoritmo gen&eacute;rico sempre ter&aacute; um desempenho razo&aacute;vel, mas ser&aacute;
     incapaz de bater o algoritmo espec&iacute;fico na classe de problemas para as quais este &eacute;
     desenhado.
</UL>

<p>
<hr>
<br>

<A NAME="cap4"></A>
<FONT SIZE=+1>Cap&iacute;tulo 4</FONT> <p>

<UL>
<LI><A HREF=Figura04.01.jpg>Figura 4.1</A>: Esquema de um algoritmo gen&eacute;tico
<LI><A HREF=Figura04.02.jpg>Figura 4.2</A>: Exemplo de interpreta&ccedil;&atilde;o de n&uacute;meros reais codificados
     de forma bin&aacute;ria
<LI><A HREF=Figura04.03.jpg>Figura 4.3</A>: Roleta viciada para indiv&iacute;duos do exemplo 4.2
<LI><A HREF=Figura04.04.jpg>Figura 4.4</A>: Exemplo de pontos de corte
<LI><A HREF=Figura04.05.jpg>Figura 4.5</A>: Descri&ccedil;&atilde;o da opera&ccedil;&atilde;o do operador de crossover
     de um ponto e muta&ccedil;&atilde;o
<LI><A HREF=Figura04.06.jpg>Figura 4.6</A>: Diagrama mostrando a estrutura das classes 
     definidas neste livro e seu relacionamento. A classe GA implementa todo o funcionamento 
     do algoritmo gen&eacute;tico e cont&eacute;m um Vector que armazena todos os indiv&iacute;duos da popula&ccedil;&atilde;o,
     cada um dos quais &eacute; um objeto da classe elementoGA.
<LI><A HREF=Figura04.07.jpg>Figura 4.7</A>: Vers&atilde;o final do nosso GA mais simples
<LI><A HREF=Figura04.08.jpg>Figura 4.8</A>: Roleta completa para a popula&ccedil;&atilde;o da primeira
     gera&ccedil;&atilde;o do exemplo da se&ccedil;&atilde;o 4.8.
<LI><A HREF=Figura04.09.jpg>Figura 4.9</A>: Operadores gen&eacute;ticos aplicados aos pais selecionados na
     primeira gera&ccedil;&atilde;o do exemplo da se&ccedil;&atilde;o 4.8.
<LI><A HREF=Figura04.10.jpg>Figura 4.10</A>: Roleta completa para a popula&ccedil;&atilde;o da segunda
     gera&ccedil;&atilde;o do exemplo da se&ccedil;&atilde;o 4.8. Note-se que o total da soma das avalia&ccedil;ões de todos
     os indiv&iacute;duos aumentou, indicando que, em m&eacute;dia, esta popula&ccedil;&atilde;o &eacute; mais adaptada ao
     problema do que a gera&ccedil;&atilde;o anterior.
</UL>

<p>
<hr>
<br>

<A NAME="cap5"></A>
<FONT SIZE=+1>Cap&iacute;tulo 5</FONT> <p>

<UL>
<LI><A HREF=Figura05.exerc1.jpg>Figura do exerc&iacute;cio resolvido n&uacute;mero 1.</A>
</UL>

<p>
<hr>
<br>

<A NAME="cap6"></A>
<FONT SIZE=+1>Cap&iacute;tulo 6</FONT> <p>

<UL>
<LI><A HREF=Figura06.01.jpg>Figura 6.1</A>: Funcionamento do crossover de dois pontos. O 
     primeiro filho &eacute; formado atrav&eacute;s da escolha do material gen&eacute;tico do primeiro pai que
     est&aacute; fora dos pontos de corte mais o material gen&eacute;tico do segundo pai entre os pontos
     de corte. O segundo filho &eacute; formado com o “resto”.
<LI><A HREF=Figura06.02.jpg>Figura 6.2</A>: Funcionamento do crossover uniforme
<LI><A HREF=Figura06.03.jpg>Figura 6.3</A>: Exemplo de opera&ccedil;&atilde;o do crossover de maioria. No caso, foram
     selecionados três pais e cada vez que um gene &eacute; igual em pelo menos dois indiv&iacute;duos,
     ele &eacute; passado para o filho. No caso dos genes das posi&ccedil;ões 1, 2 e 4 (contando a partir
     da esquerda), dois pais decidem por maioria. No caso do gene 3, existe uma unanimidade entre 
     os pais. Uma outra vers&atilde;o associa probabilidades a cada um dos genes de acordo com os
     pais. Assim, para determinar o primeiro bit do filho a se gerar far&iacute;amos um sorteio associando
     2/3 de probabilidade ao valor 1 e 1/3 ao valor 0. No caso do terceiro bit, o filho 
     teria 100% de chance de ter um bit igual a 1.
<LI><A HREF=Figura06.04.jpg>Figura 6.4</A>: Exemplo das t&eacute;cnicas de interpola&ccedil;&atilde;o parâmetros, cada uma
     das quais est&aacute; interpolando a probabilidade de um parâmetro desde 80% at&eacute; o valor final de 20%.
<LI><A HREF=Figura06.05.jpg>Figura 6.5</A>: Exemplo de escolha do esquema dominante. Quatro indiv&iacute;duos
     foram selecionados e foi verificado com o operador XNOR (XOR invertido) quais posi&ccedil;ões
     eram iguais em todos os bits. Isto permitiu criar uma m&aacute;scara contendo um para os bits que
     s&atilde;o parte do esquema e zero para os bits que n&atilde;o s&atilde;o comuns a todos os indiv&iacute;duos selecionados.
     A caixa pontilhada envolvendo três zeros mostra um problema desta abordagem: e se “quase todos” forem iguais? 
     Isto sugere que talvez seja razo&aacute;vel usar uma abordagem de maioria em vez de consenso absoluto.
<LI><A HREF=Figura06.06.jpg>Figura 6.6</A>: Exemplo de opera&ccedil;&atilde;o do crossover uniforme com 3 pais.
     O primeiro sorteio escolhe os elementos que v&atilde;o compor o primeiro filho. S&atilde;o necess&aacute;rios
     2 sorteios, pois temos três pais e o segundo sorteio escolhe, em cada posi&ccedil;&atilde;o, um n&uacute;mero
     de 0 a  2 diferente do primeiro valor sorteado para aquela posi&ccedil;&atilde;o. O terceiro filho &eacute;
     composto com o que sobra ap&oacute;s compormos os seus dois irm&atilde;os.
<LI><A HREF=Figura06.07.jpg>Figura 6.7</A>: Exemplo de opera&ccedil;&atilde;o do crossover de dois pontos
     com três pais. O primeiro filho &eacute; composto pelas partes brancas de cada pai, o segundo filho
     &eacute; composto pelas partes cheias de cada pai e o terceiro filho pelas partes quadriculadas.
</UL>


<p>
<hr>
<br>

<A NAME="cap7"></A>
<FONT SIZE=+1>Cap&iacute;tulo 7</FONT> <p>

<UL>
<LI><A HREF=Figura07.01.jpg>Figura 7.1</A>: Exemplo de uma situa&ccedil;&atilde;o em que a diversidade de
     uma popula&ccedil;&atilde;o n&atilde;o pode ser medida pela fun&ccedil;&atilde;o de avalia&ccedil;&atilde;o. Todos os elementos
     denotados pelos c&iacute;rculos têm exatamente a mesma fun&ccedil;&atilde;o de avalia&ccedil;&atilde;o. Entretanto, eles
     s&atilde;o bastante distintos, representando uma boa cobertura do espa&ccedil;o de solu&ccedil;ões. J&aacute; os
     elementos denotados pelas cruzes têm avalia&ccedil;ões bem distintas, entretanto est&atilde;o concentrados em
     um pequeno peda&ccedil;o do espa&ccedil;o de estados e, como popula&ccedil;&atilde;o, apresentam os efeitos diretos
     da convergência gen&eacute;tica.
<LI><A HREF=Figura07.02.jpg>Figura 7.2</A>: Avalia&ccedil;&atilde;o do melhor indiv&iacute;duo no caso patol&oacute;gico
     apontado no exerc&iacute;cio resolvido 7.1.a. Para que um indiv&iacute;duo da primeira gera&ccedil;&atilde;o chegue
     “vivo” ao fim do GA, Isto implica em que o melhor de todos os indiv&iacute;duos seja sempre o mesmo,
     do come&ccedil;o at&eacute; o fim do GA.
<LI><A HREF=Figura07.03.jpg>Figura 7.3</A>: Gr&aacute;ficos para o exerc&iacute;cio 2.
</UL>

<p>
<hr>
<br>

<A NAME="cap8"></A>
<FONT SIZE=+1>Cap&iacute;tulo 8</FONT> <p>

<UL>
<LI><A HREF=Figura08.01.jpg>Figura 8.1</A>: Exemplo de aplica&ccedil;&atilde;o da t&eacute;cnica de windowing.
     a) antes da aplica&ccedil;&atilde;o da t&eacute;cnica. A pequena diferen&ccedil;a entre o valor da fun&ccedil;&atilde;o de
     avalia&ccedil;&atilde;o (fitness) de cada indiv&iacute;duo se reflete na roleta, que apresenta valores
     praticamente iguais para cada indiv&iacute;duo. b) Aplicamos a t&eacute;cnica de windowing,
     diminuindo 19 de cada um dos membros da popula&ccedil;&atilde;o, o que faz com que as qualidades
     que levam o indiv&iacute;duo C a ser melhor que o resto passam a se destacar e seu espa&ccedil;o
     na roleta passa a ser 8 vezes maior que o espa&ccedil;o associado ao indiv&iacute;duo B.
<LI><A HREF=Figura08.Exerc01.jpg>Figura do exerc&iacute;cio 14</A>.
</UL>

<p>
<hr>
<br>

<A NAME="cap9"></A>
<FONT SIZE=+1>Cap&iacute;tulo 9</FONT> <p>

<UL>
<LI><A HREF=Figura09.01.jpg>Figura 9.1</A>: Exemplo de aplica&ccedil;&atilde;o do m&eacute;todo do torneio com
      k=3. &agrave; esquerda n&oacute;s temos a popula&ccedil;&atilde;o com a avalia&ccedil;&atilde;o de cada indiv&iacute;duo.  &agrave; direita,
      os elementos sorteados para cada torneio e o vencedor do mesmo, marcado com fundo 
      cinza, que se torna o pai selecionado para o operador a ser aplicado. 
<LI><A HREF=Figura09.02.jpg>Figura 9.2</A>: Exemplo de aplica&ccedil;&atilde;o do m&eacute;todo de sele&ccedil;&atilde;o de
      amostragem estoc&aacute;stica uniforme. Os indiv&iacute;duos recebem um segmento de reta proporcional
      &agrave; sua avalia&ccedil;&atilde;o. No caso do primeiro cromossomo, seu segmento de reta tem tamanho
      igual a 0,2 que &eacute; igual &agrave; sua avalia&ccedil;&atilde;o (200) dividia pela soma total das avalia&ccedil;ões
      (1000). Posteriormente, visto que queremos sortear 6 indiv&iacute;duos, um n&uacute;mero entre 0 e
      1/6 &eacute; sorteado e um ponteiro &eacute; colocado para este ponto. Depois, os ponteiros s&atilde;o
      colocados a uma distância igual a 1/6 do ponteiro imediatamente anterior e os indiv&iacute;duos para os quais eles apontam s&atilde;o os selecionados para uso dos operadores gen&eacute;ticos.
<LI><A HREF=Figura09.03.jpg>Figura 9.3</A>: Exemplo do funcionamento do operador de 
      amostragem estoc&aacute;stica uniforme quando considerado como uma roleta, ao inv&eacute;s de uma
      reta.
<LI><A HREF=Figura09.04.jpg>Figura 9.4</A>: Exemplos de vizinhan&ccedil;as em formato uni e
      bi-dimensionais. Nada impede que sejam usadas vizinhan&ccedil;as tri-dimensionais ou mesmo
      estruturadas ou mesmo convolucionadas, apesar de n&atilde;o haver estudos comprovando os
      benef&iacute;cios de estruturas mais complexas.
<LI><A HREF=Figura09.05.jpg>Figura 9.5</A>: Exemplo de aplica&ccedil;&atilde;o do m&eacute;todo de sele&ccedil;&atilde;o por
      ranking. Uma vez definidos os novos valores da fun&ccedil;&atilde;o de avalia&ccedil;&atilde;o dos indiv&iacute;duos,
      o m&eacute;todo da roleta pode ser usado como anteriormente.
</UL>

<p>
<hr>
<br>

<A NAME="cap10"></A>
<FONT SIZE=+1>Cap&iacute;tulo 10</FONT> <p>
<UL>
<LI><A HREF=Figura10.01.jpg>Figura 10.1</A>: Exemplo de forma&ccedil;&atilde;o do c&oacute;digo de Gray de 1, 2      e 3 bits. (a) C&oacute;digo de Gray de 1 bit. &eacute; s&oacute; escrever 0 e 1. (b) C&oacute;digo de Gray de 2 bits.
   Espelhamos o c&oacute;digo de Gray de 1 bit e depois colocamos 0 &agrave; frente dos n&uacute;meros acima do
   espelho e 1 &agrave; frente dos n&uacute;meros abaixo do espelho imagin&aacute;rio. (c) C&oacute;digo de Gray de 3
   bits, formado da mesma maneira que o c&oacute;digo de 2 bits. Note que os n&uacute;meros de 0 a 3 s&atilde;o
   iguais ao c&oacute;digo de 2 bits com um zero na frente, como seria de se esperar.
<LI><A HREF=Figura10.02.jpg>Figura 10.2</A>: Demonstra&ccedil;&atilde;o do processo de avalia&ccedil;&atilde;o de um cromossomo da representa&ccedil;&atilde;o baseada em ordem para solu&ccedil;&atilde;o do problema de colorir um grafo. O processo permite dois resultados: &eacute; pos&iacute;vel colorir ou n&atilde;o. &eacute; necess&aacute;rio criar algum tipo de fun&ccedil;&atilde;o que permita obter resultados intermedi&aacute;rios. Um exemplo &eacute; a determina&ccedil;&atilde;o do n&uacute;mero de n&oacute;s que n&atilde;o puderam ser coloridos, usando-se o cromossomo corrente. Isto permite que se tenha uma avalia&ccedil;&atilde;o entre 0 (todos os n&oacute;s foram coloridos) e n-k, onde n &eacute; o n&uacute;mero de n&oacute;s e k &eacute; o n&uacute;mero de cores.
<LI><A HREF=Figura10.03.jpg>Figura 10.3</A>: Exemplo de utiliza&ccedil;&atilde;o do crossover uniforme n&atilde;o adaptado para representa&ccedil;&atilde;o baseada em ordem. Note-se como cada um dos filhos gerados tem um elemento repetido, o que &eacute; proibido na representa&ccedil;&atilde;o baseada em ordem.
<LI><A HREF=Figura10.04.jpg>Figura 10.4</A>: Exemplo da atua&ccedil;&atilde;o do operador de crossover baseado em ordem
<LI><A HREF=Figura10.05.jpg>Figura 10.5</A>: Exemplo de operador de muta&ccedil;&atilde;o baseado em ordem
<LI><A HREF=Figura10.06.jpg>Figura 10.6</A>: Exemplo de opera&ccedil;&atilde;o do crossover simples. Um ponto de corte foi escolhido de forma aleat&oacute;ria e os elementos foram copiados para os filhos de forma similar ao crossover de um ponto.
<LI><A HREF=Figura10.07.jpg>Figura 10.7</A>: Exemplo de opera&ccedil;&atilde;o do crossover flat. Uma escolha completamente aleat&oacute;ria &eacute; feita para os valores de cada filho, os intervalos de cada escolha limitados pelos valores m&aacute;ximo e m&iacute;nimo de cada pai. Note que este operador &eacute; extens&iacute;vel para o caso de m&uacute;ltiplos pais, s&oacute; precisando determinar o m&aacute;ximo e o m&iacute;nimo de um grupo de n elementos, n>=2.
<LI><A HREF=Figura10.08.jpg>Figura 10.8</A>: Exemplo de opera&ccedil;&atilde;o do crossover aritm&eacute;tico, definindo o parâmetro lambda de forma arbitr&aacute;ria com o valor 0,3.
<LI><A HREF=Figura10.09.jpg>Figura 10.9</A>: Exemplo de opera&ccedil;&atilde;o do crossover discreto. Ao sortearmos o valor 0, usamos no primeiro filho a coordenada do primeiro pai e ao sortearmos o valor 1, usamos a coordenada do segundo. O segundo filho &eacute; montado com as coordenadas n&atilde;o usadas pelo primeiro. O funcionamento &eacute; perfeitamente an&aacute;logo &agrave; maneira como opera o crossover uniforme nos cromossomos bin&aacute;rios.
<LI><A HREF=Figura10.10.jpg>Figura 10.10</A>: Exemplo de atua&ccedil;&atilde;o do operador de muta&ccedil;&atilde;o aleat&oacute;ria. Os limites para o sorteio do novo valor da coordenada a sofrer muta&ccedil;&atilde;o s&atilde;o dados pelas restri&ccedil;ões e defini&ccedil;ões do problema.
<LI><A HREF=Figura10.11.jpg>Figura 10.11</A>: A nova hierarquia de classes, incluindo as classes definidas aqui para exce&ccedil;ões causadas por opera&ccedil;ões com objetos da classe CromossomoReal (circundadas pela linha tracejada). Note que o ramo das exce&ccedil;ões que n&oacute;s definimos &eacute; independente de todas as outras exce&ccedil;ões, o que garante que blocos catch n&atilde;o capturar&atilde;o inadvertidamente exce&ccedil;ões causadas por outros m&eacute;todos que n&atilde;o aqueles que desejamos.
</UL>

<p>
<hr>
<br>

<A NAME="cap11"></A>
<FONT SIZE=+1>Cap&iacute;tulo 11</FONT> <p>
<UL>
<LI><A HREF=Figura11.01.jpg>Figura 11.1</A>: Gr&aacute;fico de uma distribui&ccedil;&atilde;o normal com m&eacute;dia zero e desvio padr&atilde;o igual a 1.
<LI><A HREF=Figura11.02.jpg>Figura 11.2</A>: Evolu&ccedil;&atilde;o da &aacute;rea sob a curva normal de m&eacute;dia zero e desvio padr&atilde;o 1 como fun&ccedil;&atilde;o do valor de x.
<LI><A HREF=Figura11.03.jpg>Figura 11.3</A>: Funcionamento da regra dos trap&eacute;zios repetida. Note que a &aacute;rea total &eacute; bem aproximada pela soma das &aacute;reas dos trap&eacute;zios. Existe um erro, vis&iacute;vel na figura, mas este pode ser diminu&iacute;do arbitrariamente diminuindo-se o valor de delta x. Note que o valor do limite inferior do segundo intervalo &eacute; igual ao valor superior do primeiro intervalo.
</UL>

<p>
<hr>
<br>

<A NAME="cap12"></A>
<FONT SIZE=+1>Cap&iacute;tulo 12</FONT> <p>
<UL>
<LI><A HREF=Figura12.01.jpg>Figura 12.1</A>: Exemplo de uso pr&aacute;tico de uma &aacute;rvore na defini&ccedil;&atilde;o de hierarquia de objetos em Java. &aacute;rvores enraizadas s&atilde;o estruturas naturalmente indicadas para representa&ccedil;&atilde;o de hierarquias e, apesar das &aacute;rvores bin&aacute;rias serem as mais conhecidas, n&atilde;o existe nenhuma restri&ccedil;&atilde;o formal quanto ao n&uacute;mero de filhos que um n&oacute; pode ter.
<LI><A HREF=Figura12.02.jpg>Figura 12.2</A>: (a) uma s&eacute;rie de &aacute;rvores compostas de um &uacute;nico elemento e um candidato a raiz, r. (b) Ligando todos os elementos a r, obtemos uma nova &aacute;rvore, T, que pode ser usada em um processo similar ao que levou do item (a) ao item (b), substituindo um dos elementos simples, o que permitiria que consegu&iacute;ssemos &aacute;rvores mais complexas. O processo pode ser repetido indefinidamente, obtendo-se &aacute;rvores de qualquer complexidade desejada.
<LI><A HREF=Figura12.03.jpg>Figura 12.3</A>: Exemplo de defini&ccedil;&atilde;o de &aacute;rvores de expressões. (a) &aacute;rvore definida para a express&atilde;o x/y (b) &aacute;rvore definida para a express&atilde;o x+y*3. Note que a prioridade do operador de multiplica&ccedil;&atilde;o &eacute; naturalmente expressa pois aparecendo mais baixo na &aacute;rvore, vai ser calculado primeiro.
<LI><A HREF=Figura12.04.jpg>Figura 12.4</A>: &aacute;rvore de deriva&ccedil;&atilde;o criada para um comando while t&iacute;pico.
<LI><A HREF=Figura12.05.jpg>Figura 12.5</A>: Exemplo de como calcular a avalia&ccedil;&atilde;o de um cromossomo calculando-se a &aacute;rea entre a fun&ccedil;&atilde;o representada no cromossomo e a fun&ccedil;&atilde;o geradora dos dados (marcados com losangos). O problema desta abordagem &eacute; a necessidade de se conhecer a fun&ccedil;&atilde;o geradora, o que descaracteriza o prop&oacute;sito fundamental do GP.
<LI><A HREF=Figura12.06.jpg>Figura 12.6</A>: Exemplo do efeito do outlier. Queremos descobrir uma  fun&ccedil;&atilde;o que modele os dados representados pela linha s&oacute;lida e temos dois candidatos: a fun&ccedil;&atilde;o de linha tracejada e a fun&ccedil;&atilde;o de linha pontilhada. A de linha pontilhada modela muito melhor o processo e est&aacute; sempre mais pr&oacute;xima da fun&ccedil;&atilde;o original, com exce&ccedil;&atilde;o do ponto onde x=3. A mganitude do erro neste ponto &eacute; t&atilde;o grande que faz com que esta se torne pior do que a fun&ccedil;&atilde;o de linha tracejada, que n&atilde;o tem uma trajet&oacute;ria nem pr&oacute;xima da fun&ccedil;&atilde;o real.
<LI><A HREF=Figura12.07.jpg>Figura 12.7</A>: Exemplo da utiliza&ccedil;&atilde;o do operador de crossover com duas &aacute;rvores aleat&oacute;rias. Fazemos o sorteio para o primeiro n&iacute;vel e decidimos n&atilde;o fazer o cruzamento naquele ponto. Procedemos para um descendente do n&oacute; corrente escolhido de forma aleat&oacute;ria. Como o sorteio decidiu por fazer o crossover, intercambiamos as &aacute;rvores enraizadas no n&oacute; corrente de cada pai, gerando os dois filhos.
<LI><A HREF=Figura12.08.jpg>Figura 12.8</A>: Exemplo de utiliza&ccedil;&atilde;o do operador de muta&ccedil;&atilde;o baseado em &aacute;rvores. Um n&oacute; da &aacute;rvore original &eacute; selecionado ao acaso e a sub-&aacute;rvore enraizada neste n&oacute; &eacute; eliminada e substitu&iacute;da por outra gerada ao acaso.
</UL>

<p>
<hr>
<br>

<A NAME="cap13"></A>
<FONT SIZE=+1>Cap&iacute;tulo 13</FONT> <p>
<UL>
<LI><A HREF=Figura13.01.jpg>Figura 13.1</A>: Representa&ccedil;&atilde;o de um conjunto fuzzy atrav&eacute;s do diagrama de Hassi-Euler.
<LI><A HREF=Figura13.02.jpg>Figura 13.2</A>: Exemplo da defini&ccedil;&atilde;o de dois conjuntos expressando conceitos lingu&iacute;sticos antag&ocirc;nicos para uma mesma vari&aacute;vel.
<LI><A HREF=Figura13.03.jpg>Figura 13.3</A>: Defini&ccedil;&atilde;o de cinco conjuntos fuzzy para a vari&aacute;vel velocidade.
<LI><A HREF=Figura13.04.jpg>Figura 13.4</A>: Exemplo de execu&ccedil;&atilde;o do controle em n&iacute;vel de regras do operador de crossover. Em (a) pode-se ver a situa&ccedil;&atilde;o em que o cromossomo 1 tem apenas uma regra para o conjunto sob an&aacute;lise. Neste caso, esta &uacute;nica regra realiza o crossover com as duas regras do cromossomo 2. Em (b) pode-se ver a situa&ccedil;&atilde;o em que ambos os cromossomos têm mais de uma regra para o conjunto fuzzy. Qualquer implementa&ccedil;&atilde;o pode escolher quais regras cruzar&atilde;o de forma aleat&oacute;ria, mas deve garantir que cada regra realize o crossover ao menos uma vez
<LI><A HREF=Figura13.05.jpg>Figura 13.5</A>: Estrutura b&aacute;sica de um neur&ocirc;nio natural.
<LI><A HREF=Figura13.06.jpg>Figura 13.6</A>: Estrutura de um neur&ocirc;nio artificial. Como no caso natural, existem entradas, que s&atilde;o recebidas via pesos, ao inv&eacute;s de sinapses. O somador seguido da fun&ccedil;&atilde;o degrau fazem a vez de corpo som&aacute;tico, e a sa&iacute;da equivale ao que passa pelo ax&ocirc;nio.
<LI><A HREF=Figura13.07.jpg>Figura 13.7</A>: Exemplo de uma rede neural multi-camada
<LI><A HREF=Figura13.08.jpg>Figura 13.8</A>: Desenho de uma rede neural e exemplifica&ccedil;&atilde;o da estrutura de um gene para treinamento gen&eacute;tico dos pesos neurais
</UL>

<p>
<hr>
<br>
<A NAME="cap14"></A>
<FONT SIZE=+1>Cap&iacute;tulo 14</FONT> <p>
<UL>
<LI><A HREF=Figura14.01.jpg>Figura 14.1</A>: Exemplo de situa&ccedil;&atilde;o em que temos uma fun&ccedil;&atilde;o com m&uacute;ltiplos objetivos que s&atilde;o competitivos entre si (minimizar o tempo de atendimento e maximizar o lucro), e com restri&ccedil;ões (cada CD s&oacute; pode despachar no m&aacute;ximo a quantidade estocada). Os c&iacute;rculos representam os centros de distribui&ccedil;&atilde;o, enquanto que as estrelas representam os clientes que devem ser atendidos. Os clientes envoltos pelo c&iacute;rculo tracejado est&atilde;o a distâncias aproximadamente iguais dos centros de distribui&ccedil;&atilde;o 1 e 3. Se usarmos a heur&iacute;stica de mandar pelo CD mais pr&oacute;ximo, qual deles deve atender estes clientes?
<LI><A HREF=Figura14.02.jpg>Figura 14.2</A>: O espa&ccedil;o de solu&ccedil;ões admiss&iacute;veis &eacute; dado pela parte cheia, enquanto que o espa&ccedil;o em branco &eacute; composto de solu&ccedil;ões que n&atilde;o respeitam as restri&ccedil;ões do problema. Supondo cada coordenada como num&eacute;rica, pegamos duas solu&ccedil;ões v&aacute;lidas (c&iacute;rculos) e aplicamos o crossover aritm&eacute;tico, gerando a solu&ccedil;&atilde;o dada pelo X, que &eacute; inv&aacute;lida (est&aacute; na parte branca). Repare entretanto que ela, apesar de inv&aacute;lida, est&aacute; mais pr&oacute;xima da solu&ccedil;&atilde;o &oacute;tima (dada pelo triângulo) do que seus dois pais. Ser&aacute; que ela deve ser descartada ou reparada? M&eacute;todos de reparo podem levar esta solu&ccedil;&atilde;o em qualquer uma das duas dire&ccedil;ões dadas pelas linhas pontilhadas.
<LI><A HREF=Figura14.03.jpg>Figura 14.3</A>: Exemplo de problema de otimiza&ccedil;&atilde;o sujeito a restri&ccedil;ões. A regi&atilde;o admiss&iacute;vel, marcada em fundo cinza, possui uma s&eacute;rie de solu&ccedil;ões (c&iacute;rculos), algumas das quais muito pr&oacute;ximas &agrave; solu&ccedil;&atilde;o &oacute;tima (triângulo na parte central da figura). Existem algumas solu&ccedil;ões inadmiss&iacute;veis de baixa qualidade (X) e uma muito pr&oacute;xima &agrave; solu&ccedil;&atilde;o &oacute;tima (quadrado). Permitir que estes quadrados reproduzam poderia aumentar a chance de encontrarmos a solu&ccedil;&atilde;o &oacute;tima na pr&oacute;xima gera&ccedil;&atilde;o. Por exemplo, se considerarmos o crossover aritm&eacute;tico, a reprodu&ccedil;&atilde;o entre o elemento dado pelo quadrado e o elemento dado pelo c&iacute;rculo sem preenchimento gera uma solu&ccedil;&atilde;o que &eacute; praticamente igual ao elemento &oacute;timo. &eacute; &oacute;bvio que o exemplo &eacute; exagerado, mas todas as solu&ccedil;ões perto da borda do espa&ccedil;o admiss&iacute;vel podem trazer qualidades interessantes que poderiam melhorar o resultado final do processo de busca.
<LI><A HREF=Figura14.04.jpg>Figura 14.4</A>: Exemplo de mapeamento de um espa&ccedil;o n&atilde;o convexo para um espa&ccedil;o convexo. Repare que todas as solu&ccedil;ões que estiverem no novo espa&ccedil;o de busca (preenchido pela cor cheia e cercado pela linha tracejada) devem ser mapeadas para o espa&ccedil;o original (preenchido em xadrez). Esta abordagem resolve o problema do crossover, mas n&atilde;o o da muta&ccedil;&atilde;o. Note o ponto dentro do novo espa&ccedil;o admiss&iacute;vel, mas quase sob a borda. Se usarmos qualquer operador de muta&ccedil;&atilde;o, a regi&atilde;o marcada pelo c&iacute;rculo tracejado que envolve a solu&ccedil;&atilde;o &eacute; equiprov&aacute;vel. Logo, as muta&ccedil;&atilde;o deve ser aplicada com um cuidado adicional, para verificar a admissibilidade das solu&ccedil;ões geradas.
<LI><A HREF=Figura14.05.jpg>Figura 14.5</A>: Exemplo de conjuntos de Pareto. Cada dimens&atilde;o corresponde a um objetivo a maximizar e cada conjunto de elementos nos c&iacute;rculos tracejados correspondem a solu&ccedil;ões dominadas pelo mesmo n&uacute;mero de outras solu&ccedil;ões. Note que cada elemento pertencente ao conjunto dominado por apenas uma solu&ccedil;&atilde;o tem uma seta ligando-o ao elemento que o domina.
<LI><A HREF=Figura14.06.jpg>Figura 14.6</A>: Exemplo do grande n&uacute;mero de elementos que pertencem ao mesmo conjunto de Pareto. Na figura, podemos ver três elementos (P1, P2 e P3) que n&atilde;o s&atilde;o dominados por nenhum outro. Ao mesmo tempo, podemos ver dois grandes fronts pertencentes ao mesmo cojnunto de Pareto, de elementos que s&atilde;o dominados por apenas um indiv&iacute;duo. Se tivermos que escolher menos do que 3 elementos para uma estrat&eacute;gia elitista, qual dos melhores escolheremos? E se forem quatro? Qual dos elementos dos conjuntos circulados deve ser escolhido?

</UL>

<p>
<hr>
<br>
<A NAME="cap15"></A>
<FONT SIZE=+1>Cap&iacute;tulo 15</FONT> <p>
<UL>
<LI><A HREF=Figura15.01.jpg>Figura 15.1</A>: Ilustra&ccedil;&atilde;o do processo de migra&ccedil;&atilde;o de indiv&iacute;duos de uma popula&ccedil;&atilde;o &agrave; outra. As n melhores solu&ccedil;ões de uma ilha  (circuladas) migraram para a outra, substituindo os n piores elementos desta (cercadas pelo quadrado pontilhado). Os melhores da ilha n&atilde;o somem dela, mas sim s&atilde;o copiados para a outra e assim, cada ilha tem seus melhores e tamb&eacute;m os melhores de cada vizinho.
</UL>

<p>
<hr>
<br>

<A NAME="cap16"></A>
<FONT SIZE=+1>Cap&iacute;tulo 16</FONT> <p>
<UL>
<LI><A HREF=Figura16.01.jpg>Figura 16.1</A>: Exemplo de cromossomo em dois n&iacute;veis usado por (Petrovic, 2005).  O primeiro n&iacute;vel consiste na aloca&ccedil;&atilde;o de um conjunto de tarefas para um conjunto de m&aacute;quinas. Acima, est&atilde;o listas as tarefas componentes de cada conjunto de tarefas e as m&aacute;quinas pertencentes a cada conjunto de m&aacute;quinas. Um algoritmo simples ed aloca&ccedil;&atilde;o faz a transi&ccedil;&atilde;o do primeiro para o segundo n&iacute;vel, podendo ser usado at&eacute; mesmo um algoritmo exaustivo, visto que o n&uacute;mero de tarefas e o n&uacute;mero de m&aacute;quinas total em cada aloca&ccedil;&atilde;o &eacute; pequeno.
<LI><A HREF=Figura16.02.jpg>Figura 16.2</A>: Dois n&oacute;s especiais foram criados no grafo, representando o in&iacute;cio dos trabalhos (0, ou fonte) e o fim deles (*, ou sink). As linha s&oacute;lidas representam arestas conjuntivas, ou dependências temporais. Por exemplo, a existência de uma seta com linha s&oacute;lida entre as tarefas O21 e O22 significa que a primeira deve ser realizada antes da segunda. As linhas tracejadas indicam arestas disjuntivas, ou compartilhamento de m&aacute;quina. Assim, a existência de uma aresta de linha tracejada entre O21 e O13 indica que estas s&atilde;o realizadas na mesma m&aacute;quina.
<LI><A HREF=Figura16.03.jpg>Figura 16.3</A>: Demonstra&ccedil;&atilde;o do algoritmo de determina&ccedil;&atilde;o do n&uacute;mero de Prufer. (a) arestas do grafo foram numeradas. (b) selecionamos a folha de menor &iacute;ndice, acrescentamos seu &iacute;ndice &agrave; lista de folhas usadas e colocamos o n&oacute; ao qual ela se liga &agrave; direita n&uacute;mero de Prufer. (c) repetimos o processo do item (b). (d) repetimos o processo e agora sobrou apenas uma aresta no grafo, encerrando o processo. O n&uacute;mero de Prufer calculado &eacute; ent&atilde;o 224.
<LI><A HREF=Figura16.04.jpg>Figura 16.4</A>: Exemplos de &aacute;rvores filogen&eacute;ticas. Os c&iacute;rculos representam indiv&iacute;duos e c&iacute;rculos n&atilde;o nomeados, supostos ancestrais que s&atilde;o comuns a todos os descendentes daquele c&iacute;rculo. (a) &aacute;rvore enraizada. Quanto mais pr&oacute;ximo o ancestral em comum de duas globinas, mais similares elas s&atilde;o. (b) &aacute;rvore n&atilde;o enraizada : n&atilde;o &eacute; poss&iacute;vel determinar rela&ccedil;ões de ancestralidade entre os organismos s2 e s4.
<LI><A HREF=Figura16.05.jpg>Figura 16.5</A>: Exemplo de interpreta&ccedil;&atilde;o de representa&ccedil;&atilde;o baseada em listas no formato LISP. Como G e H est&atilde;o dentro dos parênteses de F, ent&atilde;o eles s&atilde;o descendentes deste n&oacute;. O mesmo racioc&iacute;nio pode ser aplicado v&aacute;rias vezes e vemos que A n&atilde;o est&aacute; dentro dos parênteses de nenhum outro n&oacute;, sendo portanto a raiz da &aacute;rvore filogen&eacute;tica.
</UL>

<p>
<hr>
<br>

<A NAME="ApendiceB"></A>
<FONT SIZE=+1>Apêndice B</FONT> <p>
<UL>
<LI><A HREF=FiguraB.01.jpg>Figura B.1</A>: Exemplo de execu&ccedil;&atilde;o do m&eacute;todo da bisse&ccedil;&atilde;o. Na itera&ccedil;&atilde;o 1. come&ccedil;amos com dois valores aleat&oacute;rios, a e b, tais que f(a)*f(b)<0. Escolhemos ent&atilde;o um ponto que divide o intervalo entre eles em duas partes iguais. Como sgn(f(c))=sgn(f(a)), fazemos a=c e vamos para a segunda itera&ccedil;&atilde;o, onde o processo se repete. Nesta itera&ccedil;&atilde;o, sgn(f(c))=sgn(f(b)) e fazemos b=c. O processo se repetiria at&eacute; que encontr&aacute;ssemos a raiz ou at&eacute; que f(c) menor que epsilon.
<LI><A HREF=FiguraB.02.jpg>Figura B.2</A>: Exemplo do funcionamento do algoritmo de Newton-Raphson. Come&ccedil;amos no ponto x0 e tra&ccedil;amos a reta tangente &agrave; fun&ccedil;&atilde;o neste ponto. O ponto de intercepta&ccedil;&atilde;o desta reta com o eixo das abcissas &eacute; o segundo ponto da seqüência do algoritmo, x1. Mais uma itera&ccedil;&atilde;o idêntica e chegamos a x2. Note como nos aproximamos da solu&ccedil;&atilde;o, o ponto x*.
<LI><A HREF=FiguraB.03.jpg>Figura B.3</A>: Exemplo de situa&ccedil;&atilde;o em que o algoritmo guloso n&atilde;o encontra o melhor resultado. As legendas nas arestas indicam o custo do caminho e o caminho seguido &eacute; dado pelos n&oacute;s de fundo escuro. O algoritmo guloso come&ccedil;a pelo n&oacute; 2 pois este tem o menor custo dos destinos poss&iacute;veis a partir do n&oacute; de in&iacute;cio. O mesmo vale para o n&oacute; 3 e a conseguinte chegada no objetivo. Isto faz com que  algoritmo encontre um caminho de custo 43 quando existe um caminho &oacute;timo de custo 15 (In&iacute;cio -> 2 -> 6 -> Objetivo).
</UL>

<!-- page above here -->

<hr>
<p>&nbsp;</p>

<!-- This message may not be removed! -->
<A HREF="http://www.weballey.net/"><small>Template provided by WEBalley</small></A><br>
<A HREF="http://www.weballey.net/"><img SRC="weballey.jpg" BORDER="0" width="80" height="30"></A>
<!-- This message may not be removed! -->

</BODY>
</HTML>
